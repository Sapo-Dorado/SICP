;;
;;
;;updated for 4.33-
;;
;;

(define *op-table* (make-hash-table))

(define (put type proc)
  (hash-table/put! *op-table* type proc))

(define (get type)
  (hash-table/get *op-table* type #f))

(define (exp-type exp) (car exp))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((get (exp-type exp)) ((get (exp-type exp)) exp env))
         ((application? exp)
         (proc-apply (actual-value (operator exp) env)
                     (operands exp)
                     env))
        (else
          (error "Unknown expression type: EVAL" exp))))

;;specific definitions
(define primitive-procedures 
  (list (list 'null? null?)
        (list 'cons cons)
        (list 'car car)
        (list 'cdr cdr)
        (list 'list list)
        (list '+ +)
        (list '- -)
        (list '* *)
        (list '/ /)
        (list '= =)))
(define apply-in-underlying-scheme apply)

(define (proc-apply procedure arguments env)
  (cond ((primitive-procedure? procedure) (apply-primitive-procedure procedure
                                                                     (list-of-arg-values arguments env))) 
    ((compound-procedure? procedure) (eval-sequence (procedure-body procedure)
                                                    (extend-environment (procedure-parameters procedure)
                                                                        (list-of-delayed-args arguments env)
                                                                        (procedure-environment procedure)))) 
    (else (error "Unknown procedure type: APPLY" procedure))))

(define (list-of-arg-values exps env)
  (if (no-operands? exps)
      '()
      (cons (actual-value (first-operand exps)
                          env)
            (list-of-arg-values (rest-operands exps)
                                env))))

(define (list-of-delayed-args exps env)
(if (no-operands? exps) '()
      (cons (delay-it (first-operand exps)
                      env)
            (list-of-delayed-args (rest-operands exps)
                                  env))))

(define (tagged-list? exp tag) (if (pair? exp)
            (eq? (car exp) tag)
            false))

(define (actual-value exp env) (force-it (eval exp env)))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true) 
        ((boolean? exp) true)
        (else false)))

(define (variable? exp) (symbol? exp))
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))

(define (true? x) (not (eq? x false)))
(define (false? x) (eq? x false))
(define (make-procedure parameters body env) (list 'procedure parameters body env))
(define (compound-procedure? p) (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env) (eval-sequence (rest-exps exps) env))))

;;environment operations
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
    (cons (make-frame vars vals) base-env)
    (if (< (length vars) (length vals))
          (error "Too many arguments supplied" vars vals)
          (error "Too few arguments supplied" vars vals))))
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

(define (make-frame vars values) (map cons vars values))
(define (frame-binding var frame) (assoc var frame))
(define bound? frame-binding) 
(define (add-binding-to-frame! var val frame)
  (define (add-binding! binding frame)
    (cond ((null? (cdr frame)) (set-cdr! frame binding))
          (else (add-binding! binding (cdr frame)))))
  (add-binding! (list (cons var val)) frame))
(define (set-binding-in-frame! var val frame)
  (set-cdr! (frame-binding var frame) val))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (if (bound? var frame)
              (cdr (frame-binding var frame))
              (env-loop (enclosing-environment env))))))
  (env-loop env))
 
(define (set-variable-value! var val env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (if (bound? var frame)
              (set-binding-in-frame! var val frame)
              (env-loop (enclosing-environment env))))))    
  (env-loop env))
 
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (if (bound? var frame)
        (set-binding-in-frame! var val frame)
        (add-binding-to-frame! var val frame))))

;;representing thunks
(define (delay-it exp env) (list 'thunk exp env))
(define (thunk? obj) (tagged-list? obj 'thunk))
(define (thunk-exp thunk) (cadr thunk))
(define (thunk-env thunk) (caddr thunk))

(define (evaluated-thunk? obj) (tagged-list? obj 'evaluated-thunk))
(define (thunk-value evaluated-thunk) (cadr evaluated-thunk))
(define (force-it obj)
  (cond ((thunk? obj)
         (let ((result (actual-value (thunk-exp obj) (thunk-env obj))))
           (set-car! obj 'evaluated-thunk)
           (set-car! (cdr obj) result)
           (set-cdr! (cdr obj) '())
           result))
           ((evaluated-thunk? obj) (thunk-value obj))
           (else obj)))

;;table operations
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)
(define (assignment? exp) (tagged-list? exp 'set!))

(define (definition-variable exp)
  (if (symbol? (cadr exp))
    (cadr exp)
    (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp)) (caddr exp)
    (make-lambda (cdadr exp)
                  (cddr exp))))
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                  (eval (definition-value exp) env)
                  env)
  'ok)
(define (definition? exp) (tagged-list? exp 'define))

(define (eval-quoted exp env)
  (text-of-quotation exp env))
(define (quotation->cons exp)
  (if (null? exp)
      exp
      (list 'cons (list 'quote (car exp)) (quotation->cons (cdr exp)))))
(define (text-of-quotation exp env)
  (let ((result (cadr exp)))
    (if (pair? result)
        (eval (quotation->cons result) env)
        result)))
(define (quoted? exp) (tagged-list? exp 'quote))

(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-lambda parameters body) (cons 'lambda (cons parameters body)))
(define (lambda? exp) (tagged-list? exp 'lambda))

(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
    (cadddr exp)
    'false))
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
(define (eval-if exp env)
  (if (true? (actual-value (if-predicate exp) env))
    (eval (if-consequent exp) env)
    (eval (if-alternative exp) env)))
(define (if? exp) (tagged-list? exp 'if))


(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))
(define (begin? exp) (tagged-list? exp 'begin))

(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond-recipient clause) (caddr clause))
(define (cond-recipient-clause? clause) (eq? (cadr clause) '=>))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (make-cond-recipient clause predicate)
  (list (cond-recipient clause) predicate))
(define (cond-consequent clause predicate)
  (if (cond-recipient-clause? clause)
      (make-cond-recipient clause predicate)
      (sequence->exp (cond-actions clause))))
(define (cond? exp) (tagged-list? exp 'cond))

(define (expand-clauses clauses)
  (if (null? clauses)
    'false
    (let ((first (car clauses)) (rest (cdr clauses)))
      (if (cond-else-clause? first)
        (if (null? rest)
          (sequence->exp (cond-actions first))
          (error "ELSE clause isn't last: COND->IF" clauses))
          (make-if (cond-predicate first)
                    (cond-consequent (cond-actions first))
                    (expand-clauses rest))))))

(define (and-exps exp) (cdr exp))
(define (first-and exp) (car exp))
(define (rest-and exp) (cdr exp))
(define (and? exp) (tagged-list exp 'and))
(define (eval-and exp env)
  (let ((expression (and-exps exp)))
    (if (null? expression)
      (error: "null and expression EVAL-AND"))
    (define (iter exp)
      (cond ((null? exp) #t)
            ((not (true? (eval (first-and exp) env))) #f)
            (else (iter (rest-and exp)))))
    (iter expression)))

(define (or-exps exp) (cdr exp))
(define (first-or exp) (car exp))
(define (rest-or exp) (cdr exp))
(define (or? exp) (tagged-list? exp 'or))
(define (eval-or exp env)
  (let ((expression (or-exps exp)))
    (define (iter exp)
      (cond ((null? exp) #f)
            ((true? (eval (first-or exp) env)) #t)
            (else (iter (rest-or exp)))))
    (iter expression)))
  
(define (let-assignments exp) (cadr exp))
(define (let-body exp) (cddr exp))
(define (let-vars exp) (map car (let-assignments exp)))
(define (let-vals exp) (map cadr (let-assignments exp)))
(define (make-let parameters body)
  (cons 'let (cons parameters body)))
(define (let? exp) (tagged-list? exp 'let))
(define (named-let? exp)
  (and (tagged-list? exp 'let))
  (symbol? (cadr exp)))
(define (named-let-identifier exp) (car exp))
(define (named-let->combination exp)
  (let ((procedure-name (named-let-identifier exp)))
    (make-begin 
     (list
      (list 'define procedure-name 
            (make-lambda 
             (let-vars exp) 
             (let-body exp)))
      (cons procedure-name (let-vals exp))))))

(define (let->combination exp)
  (if (named-let? exp)
    (named-let->combination (cdr exp))
    (cons (make-lambda (let-vars exp) (let-body exp)) (let-vals exp))))

(define (let*-parameters exp) (cadr exp))
(define (let*-body exp) (cddr exp))
(define (first-let* parameters) (car parameters))
(define (rest-let* parameters) (car parameters))
(define (let*? exp) (tagged-list? exp 'let*))
(define (let*->nested-lets exp)
  (define (iter parameters body)
    (cond ((null? parameters) body) 
          (else (make-let (first-let* parameters)
                          (iter (rest-let* parameters))))))
  (iter (let*-parameters exp) (let*-body exp)))



  

(put 'quote eval-quoted)
(put 'set! eval-assignment)
(put 'define eval-definition)
(put 'if eval-if)
(put 'lambda (lambda (exp env) (make-procedure (lambda-parameters exp)
                                                (lambda-body exp)
                                                env)))
(put 'begin (lambda (exp env) (eval-sequence (begin-actions exp) env)))
(put 'cond (lambda (exp env) (eval (cond->if exp) env)))
(put 'and eval-and)
(put 'or eval-or)
(put 'let (lambda (exp env) (eval (let->combination exp) env)))
(put 'let* (lambda (exp env) (eval (let*->nested-lets exp) env)))


;global environment
(define (setup-environment)
  (let ((initial-env (extend-environment (primitive-procedure-names)
                                         (primitive-procedure-objects)
                                         the-empty-environment)))
    (define-variable! 'true #t initial-env)
    (define-variable! 'false #f initial-env)
    initial-env))

(define (primitive-procedure? proc) (tagged-list? proc 'primitive))
(define (primitive-implementation proc) (cadr proc))
(define (primitive-procedure-names) (map car primitive-procedures))
(define (primitive-procedure-objects) (map (lambda (proc) (list 'primitive (cadr proc))) primitive-procedures))
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

(define input-prompt ";;; L-Eval input:")
(define output-prompt ";;; L-Eval value:")
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (actual-value input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline) (newline) (display string) (newline))
(define (announce-output string)
  (newline) (display string) (newline))

(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
                     (procedure-parameters object)
                     (procedure-body object)
                     '<procedure-env>))
      (display object)))

(define the-global-environment (setup-environment))
(eval '(define (cons x y) (lambda (m) (m x y))) the-global-environment)
(eval '(define (car z) (z (lambda (p q) p))) the-global-environment)
(eval '(define (cdr z) (z (lambda (p q) q))) the-global-environment)
(driver-loop)
