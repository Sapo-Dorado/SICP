(define *op-table* (make-hash-table))

(define (put op type proc)
  (hash-table/put! *op-table* (list op type) proc))

(define (get op type)
  (hash-table/get *op-table* (list op type) #f))

(define (exp-type exp) (car exp))

(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((get (type exp)) ((get (type exp)) exp env))
         ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
          (error "Unknown expression type: EVAL" exp))))

;;specific definitions
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure) (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure) (eval-sequence (procedure-body procedure)
                                                        (extend-environment (procedure-parameters procedure)
                                                                            arguments
                                                                            (procedure-environment procedure))))
        (else (error "Unknown procedure type: APPLY" procedure))))


(define (list-of-values exps env)
  (if (no-operands? exps)
      '()
      (cons (eval (first-operand exps) env)
            (list-of-values (rest-operands exps) env))))

(define (eval-sequence exps env)
  (cond ((last-exp? exps) (eval (first-exp exps) env))
        (else (eval (first-exp exps) env) (eval-sequence (rest-exps exps) env))))

(define (self-evaluating? exp)
  (cond ((number? exp) true)
        ((string? exp) true) 
        ((boolean? exp) true)
        (else false)))

(define (variable? exp) (symbol? exp))
(define (application? exp) (pair? exp))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (no-operands? ops) (null? ops))
(define (first-operand ops) (car ops))
(define (rest-operands ops) (cdr ops))


(define (true? x) (not (eq? x false)))
(define (false? x) (eq? x false))
(define (make-procedure parameters body env) (list 'procedure parameters body env))
(define (compound-procedure? p) (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))

;;environment operations
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())

(define (make-frame vars values) (map cons vars values))
(define (frame-binding var frame) (assoc var frame))
(define bound? frame-binding) 
(define (add-binding-to-frame! var val frame)
  (define (add-binding! binding frame)
    (cond ((null? (cdr frame)) (set-cdr! frame binding))
          (else (add-binding! binding (cdr frame)))))
  (add-binding! (list (cons var val)) frame))
(define (set-binding-in-frame! var val frame)
  (set-cdr! (frame-binding var frame) val))

(define (lookup-variable-value var env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound variable" var)
        (let ((frame (first-frame env)))
          (if (bound? var frame)
              (cdr (frame-binding var frame))
              (env-loop (enclosing-environment env))))))
  (env-loop env))
 
(define (set-variable-value! var val env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
        (error "Unbound variable -- SET!" var)
        (let ((frame (first-frame env)))
          (if (bound? var frame)
              (set-binding-in-frame! var val frame)
              (env-loop (enclosing-environment env))))))    
  (env-loop env))
 
(define (define-variable! var val env)
  (let ((frame (first-frame env)))
    (if (bound? var frame)
        (set-binding-in-frame! var val frame)
        (add-binding-to-frame! var val frame))))

;;table operations
(define (assignment-variable exp) (cadr exp))
(define (assignment-value exp) (caddr exp))
(define (eval-assignment exp env)
  (set-variable-value! (assignment-variable exp)
                      (eval (assignment-value exp) env)
                      env)
  'ok)

(define (definition-variable exp)
  (if (symbol? (cadr exp))
    (cadr exp)
    (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp)) (caddr exp)
    (make-lambda (cdadr exp)
                  (cddr exp))))
(define (eval-definition exp env)
  (define-variable! (definition-variable exp)
                  (eval (definition-value exp) env)
                  env)
  'ok)

(define (text-of-quotation exp) (cadr exp))

(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (make-lambda parameters body) (cons 'lambda (cons parameters body)))

(define (if-predicate exp) (cadr exp))
(define (if-consequent exp) (caddr exp))
(define (if-alternative exp)
  (if (not (null? (cdddr exp)))
    (cadddr exp)
    'false))
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
(define (eval-if exp env)
  (if (true? (eval (if-predicate exp) env))
    (eval (if-consequent exp) env)
    (eval (if-alternative exp) env)))


(define (begin-actions exp) (cdr exp))
(define (last-exp? seq) (null? (cdr seq)))
(define (first-exp seq) (car seq))
(define (rest-exps seq) (cdr seq))
(define (sequence->exp seq)
  (cond ((null? seq) seq)
        ((last-exp? seq) (first-exp seq))
        (else (make-begin seq))))
(define (make-begin seq) (cons 'begin seq))

(define (cond-clauses exp) (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause) (car clause))
(define (cond-actions clause) (cdr clause))
(define (cond-recipient clause) (caddr clause))
(define (cond-recipient-clause? clause) (eq? (cadr clause) '=>))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (make-cond-recipient clause predicate)
  (list (cond-recipient clause) predicate))
(define (cond-consequent clause predicate)
  (if (cond-recipient-clause? clause)
      (make-cond-recipient clause predicate)
      (sequence->exp (cond-actions clause))))

(define (expand-clauses clauses)
  (if (null? clauses)
    'false
    (let ((first (car clauses)) (rest (cdr clauses)))
      (if (cond-else-clause? first)
        (if (null? rest)
          (sequence->exp (cond-actions first))
          (error "ELSE clause isn't last: COND->IF" clauses))
          (make-if (cond-predicate first)
                    (cond-consequent (cond-actions first))
                    (expand-clauses rest))))))

(define (and-exps exp) (cdr exp))
(define (first-and exp) (car exp))
(define (rest-and exp) (cdr exp))
(define (eval-and exp env)
  (let ((expression (and-exps exp)))
    (if (null? exp)
      (error: "null and expression EVAL-AND"))
    (define (iter exp env)
      (cond ((null? exp) #t)
            ((not (true? (eval (first-and exp) env))) #f)
            (else (iter (rest-and exp) env))))
    (iter exp env)))

(define (or-exps exp) (cdr exp))
(define (first-or exp) (car exp))
(define (rest-or exp) (cdr exp))
(define (eval-or exp env)
  (let ((expresion (or-exps exp)))
    (define (iter exp env)
      (cond ((null? exp) #f)
            ((true? (eval (first-or exp))) #t)
            (else (iter (rest-or exp) env))))
    (iter exp env)))
  
(define (let-assignments exp) (cadr exp))
(define (let-body exp) (cddr exp))
(define (let-vars exp) (map car (let-assignments exp)))
(define (let-vals exp) (map cadr (let-assignments exp)))
(define (make-let parameters body)
  (cons 'let (cons parameters body)))
(define (named-let? exp) (symbol? (cadr exp)))
(define (named-let-identifier exp) (car exp))
(define (named-let->combination exp)
  (let ((procedure-name (named-let-identifier exp)))
    (make-begin 
     (list
      (list 'define procedure-name 
            (make-lambda 
             (let-vars exp) 
             (let-body exp)))
      (cons procedure-name (let-vals exp))))))

(define (let->combination exp)
  (if (named-let? exp)
    (named-let->combination (cdr exp))
    (cons (make-lambda (let-vars exp) (let-body)) (let-vals exp))))

(define (let*-parameters exp) (cadr exp))
(define (let*-body exp) (cddr exp))
(define (first-let* parameters) (car parameters))
(define (rest-let* parameters) (car parameters))
(define (let*->nested-lets exp)
  (define (iter parameters body)
    (cond ((null? parameters) body) 
          (else (make-let (first-let* parameters)
                          (iter (rest-let* parameters))))))
  (iter (let*-parameters exp) (let*-body exp)))



  

(put 'quote (lambda (exp env) (text-of-quotation exp)))
(put 'set! eval-assignment)
(put 'define eval-definition)
(put 'if eval-if)
(put 'lambda (lambda (exp env) (make-procedure (lambda-parameters exp)
                                                (lambda-body exp)
                                                env)))
(put 'begin (lambda (exp env) (eval-sequence (begin-actions exp) env)))
(put 'cond (lambda (exp env) (eval (cond->if exp) env)))
(put '&& eval-and)
(put '|| eval-or)
(put 'let (lambda (exp env) (eval (let->combination exp) env)))
(put 'let* (lambda (exp env) (eval (let*->nested-lets exp) env)))
