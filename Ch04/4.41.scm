;;forgot about flatmap so i designed my own permutations procedure not pretty cuz i wasnt sure the best way to accumulate the answers so I mutated a variable
(define (distinct? items)
  (cond ((null? items) true)
    ((null? (cdr items)) true)
    ((member (car items) (cdr items)) false)
    (else (distinct? (cdr items)))))
(define (make-dwellings)
  (let ((baker (list 1 2 3 4 5))
        (cooper (list 1 2 3 4 5))
        (fletcher (list 1 2 3 4 5))
        (miller (list 1 2 3 4 5))
        (smith    (list 1 2 3 4 5)))
    (set! baker (filter (lambda (x) (not (= x 5))) baker))
    (set! cooper (filter (lambda (x) (not (= x 1))) cooper))
    (set! fletcher (filter (lambda (x) (not (= x 1))) fletcher))
    (set! fletcher (filter (lambda (x) (not (= x 5))) fletcher))
    (define (make-all-possibilities)
      (let ((possibilities '()))
        (define (each-item-in-first first combination)
          (if  (not (null? first))
               (begin (set! possibilities (cons (append combination (list (car first))) possibilities))
                      (each-item-in-first (cdr first) combination))))
        (define (enumerate-possibilities first rest combination)
          (cond ((null? rest) (each-item-in-first first combination))
                ((null? first) 'ok)
                (else (enumerate-possibilities (car rest) (cdr rest) (append combination (list (car first))))
                      (enumerate-possibilities (cdr first) rest combination))))
       (enumerate-possibilities baker (list cooper fletcher miller smith) '())
       possibilities))
    (define (ans-filter test)
      (let ((baker (car test))
            (cooper (cadr test))
            (fletcher (caddr test))
            (miller (cadddr test))
            (smith (car (cddddr test))))
        (and (> miller cooper)
             (not (= (abs (- fletcher cooper)) 1))
             (not (= (abs (- smith fletcher)) 1))
             (distinct? test))))
    (filter ans-filter (make-all-possibilities))))


(make-dwellings)
